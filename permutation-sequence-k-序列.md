# 如何把一个 O(n!) 优化成一个 O(n)

$$可能是最快的解法$$ 

题目出自 leetcode [第 k 个排列](https://leetcode-cn.com/problems/permutation-sequence/)

> 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。
>
> 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：
>
> "123"
> "132"
> "213"
> "231"
> "312"
> "321"
> 给定 n 和 k，返回第 k 个排列。
>
> 说明：
>
> 给定 n 的范围是 [1, 9]。
> 给定 k 的范围是[1,  n!]。
> 示例 1:
>
> 输入: n = 3, k = 3
> 输出: "213"
> 示例 2:
>
> 输入: n = 4, k = 9
> 输出: "2314"

-----

先用最简单的方式实现 暴力枚举所有可能的结果然后排序, 然后选择第 k 个子序列, 这里选择 n = 4, k = 8, 来举例子。全排列得到的结果是: `[1234, 1243, ... , 4312, 4321]` 一共有 4! 中可能的结果, 然后选择第 k 个输出即可。

然而只能做到这样了么? 

### 如何做到 O(n) 的

> 以下的假设都假定 n = 4 , 先来看看组合的规律吧, 

```go

[
    [1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2],  // 这一行表示以数字 '1' 开头, 一共有 3! 个组合
    [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1],  // 这一行表示以数字 '2' 开头, 一共有 3! 个组合
    [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1],  // 这一行表示以数字 '3' 开头, 一共有 3! 个组合
    [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1],  // 这一行表示以数字 '4' 开头, 一共有 3! 个组合
]

```

> 从上面的规则可以发现, 以 `1` 开头的全排列有 `3!` 种(2, 3, 4 的亦然), 然后来看看 以 `12` 开头的全排列一共有 `2!`  种(`13`, `14` 的亦然), 然后再来看看以 `123` 开头的全排列一种有 `1!` 种  (`1234`)
>
> 然后再看每一次选择完一个数字之后, 下一次可选的数字将会把这一次选择排序的数值给剔除了(其实这个数字已经加入到已经排序的尾部, 也就是接下来子序列的公共前缀), 什么意思呢?  



使用 `n = 4, k = 8 ` 来举例子

从上面个的规则可以看到, 以数字 `1`, `2`, `3`, `4` 开头的全排列的个数都是 `3!` 种, 现在我们需要确定 `k = 8 ` 需要哪种数字开头的全排列, 通过计算公式,  `row = 8/6`, `col = 8%6`, 其中 `row` 可以确定本次全排列可以使用哪个数字作为本次全排列的开头, 这里的 `row == 1` 表示可以使用本轮下标可选择的全排列的数字中选择下标为 1 的数值作为开头, 而 `col == 2` 表示下一次全排列的结果需要选择第几个, **这里需要说明一点, 如果 col == 0, 表示本轮的全排列的结果的最大值可以作为完整的结果输出**,  什么意思?  我还是在下面看个完整的例子吧。



### 使用 n =4, k = 8 来举例

​	构造 `data = []int{1, 2, 3, 4}`, `seq = []int{}`, 这里的 `data` 是本次全排列可以选择的数字, `seq` 本次全排列的前缀数字

1.  row = k / (n - 1)! == 1, col = k %(n -1)! ==2,  row 这里表示第一次选择本次全排列开头的数字是以本次可以选择全排列列表的下标, 这里表示本次选择的前缀是数字 `2`, `col == 2 `表示下一次全排列的 k 值, 这里轮完成之后, 更新 `data = {1, 3, 4}`, `seq = {2}`, `n = 3`, `k = 2`

2. 继续令 row = k / (n -1)! == 1, col = k % (n - 1)! == 0 , **注意这里的 `col == 0 ` 表示上一行全排列的最大值既可以满足所有的条件! ** 什么意思呢? 我们来看看本轮全排列的所有结果吧。

   ```go
   
   [
      [2, 1, 3, 4], [2, 1, 4, 3], // 这一行表示本轮的全排列的结果是以 21 开头
      [2, 3, 1, 4], [2, 3, 4, 1], // 这一行表示本轮的全排列的结果是以 23 开头
      [2, 4, 1, 3], [2, 4, 3, 1], // 这一行表示本轮的全排列的结果是以 24 开头
   ]
   
   ```

   这一个步骤得到的 `row == 1`, 理应该在本轮全排列可选的数值中`data={1, 3, 4}` 中选择下标为 `1` 的数字 `3` 的, 但是 `col == 0 `, 表示下标为 `row` 的上一行全排列的结果即可满足全排列的输出结果, 然后我们将 `row -=1 `作为本次全排列的一个前缀, 然后将剩下的所有结果 反转之后再添加进入 `seq`, 那么本轮 `seq` 的结果就是 `seq = {2, 1}`, `data = {3, 4}`, 然后将 `data` 的所有数据反转之后 `data = {4, 3}`全部追加到 `seq`, `seq` 最终的结果为 `seq = {2, 1, 4, 3}`, `data = {}` , 由于data 中的数据为空, 我们退出全排列, 将 `seq` 中的所有数值按顺序串化即可得到我们需要的结果

   



### 结论

$$ k = x * (n -1)! + r $$, x 是本轮迭代得到的对应的下标, r 是下一轮迭代的 k, **如果 r == 0, 表示上一个组合, 选择 data[x-1] 为前缀的最大值就是本轮所求的结果**

### 代码实现 

这里实现语言使用的是 go

```go
package main

import (
	"fmt"
	"strconv"
	"strings"
)

func main() {
	sl := []int{1, 2, 3}
	fmt.Println(sl, )
	//fmt.Println(getPermutation(4, 8)) // 2143
	fmt.Println(getPermutation(4, 7))  // 2134
	fmt.Println(getPermutation(4, 6))  // 1432
	fmt.Println(getPermutation(2, 2))  // 21
	fmt.Println(getPermutation(3, 4))  // 231
	fmt.Println(getPermutation(3, 6))  // 
	fmt.Println(getPermutation(4, 18)) // 
}

func getPermutation(n int, k int) string {
	if n == 1 {
		return "1"
	}
	data := make([]int, n)
	for i := 0; i < n; i++ {
		data[i] = i + 1
	}

	m := make([]int, 0)
	for len(data) != 0 {

		r := rev(n - 1)
		currIndex := k / r
		md := k % r
		// 如果当前的可以整除, 并且余数为零, 表示商的上一行的最大值就是所求的结果
		if md == 0 && currIndex != 0 {
			currIndex -= 1
			m = append(m, data[currIndex])
			data = append(data[0:currIndex], data[currIndex+1:]...)
			reverseSL(data)
			m = append(m, data...)
			data = []int{}
		} else {
			// 如果 余数不为零, 表示 本轮所求的结果在 商所在的那一行
			m = append(m, data[currIndex])
			data = append(data[0:currIndex], data[currIndex+1:]...)
			k = md
			n = n - 1
		}
	}

	sb := strings.Builder{}
	for i := 0; i < len(m); i++ {
		sb.WriteString(strconv.Itoa(m[i]))
	}
	return sb.String()
}


func rev(n int) int {
	sum := 1
	for i := 1; i <= n; i++ {
		sum *= i
	}
	return sum
}

// 翻转data
func reverseSL(data [] int) {
	for i, j := 0, len(data)-1; i < j; i, j = i+1, j-1 {
		data[i], data[j] = data[j], data[i]
	}
}


```





## 优化部分

> 可以看到在求 (n-1)! 的时候使用了 一个 `rev` 函数, 这样会导致 `i` 的阶乘至少重复计算了 `n-i` 次,  使用 slice `factorial = [1, 2*1!, 3*2!, ... , n * (n-1)!]` 可以减少多次的重复计算





​	

​																																																

​																																																	2019年9月28日

